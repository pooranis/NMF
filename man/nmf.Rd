% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nmf.R
\name{nmf}
\alias{nmf}
\title{Running NMF algorithms}
\usage{
nmf(x, rank, method, ...)
}
\arguments{
\item{x}{target data to fit, i.e. a matrix-like object}

\item{rank}{specification of the factorization rank.
It is usually a single numeric value, but other type of values are possible 
(e.g. matrix), for which specific methods are implemented.
See for example methods \code{nmf,matrix,matrix,ANY}.

If \code{rank} is a numeric vector with more than one element, e.g. a range of ranks, 
then \code{\link{nmf}} performs the estimation procedure described in 
\code{\link{nmfEstimateRank}}.}

\item{method}{specification of the NMF algorithm.
The most common way of specifying the algorithm is to pass the access key 
(i.e. a character string) of an algorithm stored in the package's dedicated registry, 
but methods exists that handle other types of values, such as \code{function} or \code{list} 
object. See their descriptions in section \emph{Methods}.

If \code{method} is missing the algorithm to use is obtained from the option 
\code{nmf.getOption('default.algorithm')}, unless it can be infer from the type of NMF model 
to fit, if this later is available from other arguments. 
Factory fresh default value is \sQuote{brunet}, which corresponds to the standard NMF 
algorithm from \cite{Brunet2004} (see section \emph{Algorithms}).

Cases where the algorithm is inferred from the call are when an NMF model is passed in arguments \code{rank} 
or \code{seed} (see description for \code{nmf,matrix,numeric,NULL} in section \emph{Methods}).}

\item{...}{extra arguments to allow extension of the generic.
Arguments that are not used in the chain of internal calls to \code{nmf} methods 
are passed to the function that effectively implements the algorithm that fits 
an NMF model on \code{x}.}
}
\description{
The function \code{nmf} is a S4 generic defines the main interface to run NMF 
algorithms within the framework defined in package \code{NMF}.
It has many methods that facilitates applying, developing and testing NMF 
algorithms.

The package vignette \code{vignette('NMF')} contains an introduction to the 
interface, through a sample data analysis.
}
\details{
The \code{nmf} function has multiple methods that compose a very flexible 
interface allowing to:
\itemize{
\item combine NMF algorithms with seeding methods and/or stopping/convergence 
criterion at runtime;

\item perform multiple NMF runs, which are computed in parallel whenever the host 
machine allows it;

\item run multiple algorithms with a common set of parameters, ensuring a 
consistent environment (notably the RNG settings).
}

The workhorse method is \code{nmf,matrix,numeric,NMFStrategy}, which is eventually 
called by all other methods.
The other methods provides convenient ways of specifying the NMF algorithm(s),  
the factorization rank, or the seed to be used.
Some allow to directly run NMF algorithms on different types of objects, such 
as \code{data.frame} or \code{\link[Biobase]{ExpressionSet}} objects.
}
\section{Optimized C++ vs. plain R}{
 
Lee and Seung's multiplicative updates are used by several NMF algorithms. To improve 
speed and memory usage, a C++ implementation of the specific matrix products is used 
whenever possible. It directly computes the updates for each entry in the updated matrix, 
instead of using multiple standard matrix multiplication.

The algorithms that benefit from this optimization are: 'brunet', 'lee', 'nsNMF' and 'offset'. % and 'lnmf'
However there still exists plain R versions for these methods, which implement the updates 
as standard matrix products. These are accessible by adding the prefix '.R#' to their name: 
'.R#brunet', '.R#lee', '.R#nsNMF' and '.R#offset'.
}

\examples{

# Only basic calls are presented in this manpage.
# Many more examples are provided in the demo file nmf.R
\dontrun{
demo('nmf')
}

# random data
x <- rmatrix(20,10)

# run default algorithm with rank 2
res <- nmf(x, 2)

# specify the algorithm
res <- nmf(x, 2, 'lee')

# get verbose message on what is going on
res <- nmf(x, 2, .options='v') 
\dontrun{ 
# more messages
res <- nmf(x, 2, .options='v2')
# even more
res <- nmf(x, 2, .options='v3')
# and so on ... 
}
 
}
